#!/bin/bash

###
# 
# fuzzycactus-- A tool which automates and simplifies the on-device fuzzing of MobileSafari
# View the source for this project on github: https://github.com/compilingEntropy/fuzzycactus
# Report bugs or ask questions
# email: compilingEntropy@gmail.com
# twitter: @compiledEntropy
# 
# Version 2.1.5
# 
# Dependencies:
# A file to fuzz with
# zzuf
# sbutils
# bc
# lighttpd
# adv-cmds
# cURL
# wget
# coreutils
# 
# Installs to /usr/bin/fuzzycactus
# Working directory is /private/var/fuzzycactus/
# 
###

version="2.1.5"
currentpid=$$
action="$1"
file="$2"
params=( $( for arg in $@; do echo "$arg"; done ) )
usage="Usage: fuzzycactus [action] [file] [options]\nfuzzycactus [start/stop/watch/update/help] [./file.mov] [-s] [-t 11] [-r 0.0001:0.001] [-k]"
wrkdir="/private/var/fuzzycactus"
config="$wrkdir/fuzzycactus.conf"
launchd="/System/Library/LaunchDaemons/com.compilingentropy.fuzzycactus.plist"
sysversion="/System/Library/CoreServices/SystemVersion.plist"
extended_states="/var/lib/apt/extended_states"
lighttpdconf="/private/etc/lighttpd.conf"
pidfile="$wrkdir/pid"

if [[ -z "$action" ]]; then
	echo "You must provide an action."
	echo -e "$usage"
	exit
fi

#smart functions with built-in checks
smart_mkdir()
{
	if [[ ! -d "$1" ]]; then
		mkdir -p "$1"
	fi
}
smart_cd()
{
	smart_mkdir "$1"
	cd "$1"
}
smart_touch()
{
	if [[ ! -e "$1" ]]; then
		touch "$1"
	fi
}
smart_rm()
{
	if [[ -e "$1" ]]; then
		if [[ -z "$2" ]]; then
			rm "$1"
		else
			rm "$2" "$1"
		fi
	fi
}
smart_mv()
{
	if [[ -e "$1" ]]; then
		mv "$1" "$2"
	fi
}

#make wrkdir
smart_mkdir "$wrkdir/"

#pid file
if [[ -e "$pidfile" ]]; then
	echo "$currentpid" >> "$pidfile"
else
	#generate new pidfile file
	echo "###
#
#This is the fuzzycactus pid file.
#DO NOT MODIFY THIS FILE!!! PLZ!! 
#I R OF BEG U #HOLMES
#
###
" > "$pidfile"
fi

#removes the pid of the current process from the pidfile
removecurrentpid()
{
	if [[ -e "$pidfile" ]]; then
		sed -i "/$currentpid/d" "$pidfile"
	else
		echo "$pidfile does not exist!"
	fi
}

#common end scenario
cleanexit()
{
	removecurrentpid
	exit
}

##regular expressions r of cool #HOLMES
#set file read pattern matching formats
stimefileregex="(^stime: [0-9]{2}[\.][0-9]{2}[\.][0-9]{2}[-][0-9]{2}[\.][0-9]{2}[\.][0-9]{2}$)"
ratiofileregex="(^ratio: [0]*[\.][0-9]+[:][0]*[\.][0-9]+$)|(^[0]*[\.][0-9]+$)"
timefileregex="(^time: [0-9]+$)|(^[0-9]+[\.][0-9]+$)"
slowdownfileregex="(^slowdown: [0-1]$)"
kernelfileregex="(^kernel: [0-1]$)"
crashesfileregex="(^crashes: [0-9]+$)"
safarifileregex="(^safari: /private/var/mobile/Library/$)|(^safari: /private/var/mobile/Applications/[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}/Library/$)|(^safari: /private/var/mobile/Containers/Data/Application/[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}/Library/$)"
#set data pattern matching formats
stimeregex="([0-9]{2}[\.][0-9]{2}[\.][0-9]{2}[-][0-9]{2}[\.][0-9]{2}[\.][0-9]{2}$)"
ratioregex="([0]*[\.][0-9]+[:][0]*[\.][0-9]+$)|([0]*[\.][0-9]+$)"
timeregex="([0-9]+$)|([0-9]+[\.][0-9]+$)"
slowdownregex="([0-1]$)"
kernelregex="([0-1]$)"
crashesregex="([0-9]+$)"
safariregex="(/private/var/mobile/Library/$)|(/private/var/mobile/Applications/[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}/Library/$)|(/private/var/mobile/Containers/Data/Application/[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}/Library/$)"
#bonus regexes
dateregex="([0-9]{4}.[0-9]{2}.[0-9]{2}.[0-9]{2}.[0-9]{2}.[0-9]{2})"
versionregex="([0-9]+[\.][0-9]+[\.][0-9]+|[0-9]+[\.][0-9]+)"

#determine whether fuzzycactus is already running
is_running()
{
	isrunning=0
	if [[ -e "$pidfile" ]]; then
		if [ $( egrep -c "(^[0-9]+$)" "$pidfile" ) -ge 1 ]; then
			pidlist=( $( egrep -o "(^[0-9]+$)" "$pidfile" ) )
			pidlist=( "${pidlist[@]/$currentpid/}" )
			for pid in "${pidlist[@]}"; do
				kill -0 "$pid" &> /dev/null; isdead="$?"
				if [ $isdead -eq 0 ]; then
					isrunning=1
				fi
			done
		fi
	else
		echo "no dont do that"
	fi
}

#get major system version
getversion()
{
	ios=$( sbdevice -V )
	if [ $( echo "$ios" | egrep -c "$versionregex" ) -ne 1 ]; then
		if [[ -e "$sysversion" ]]; then
			ios=$( grep -A 1 "ProductVersion" "$sysversion" | egrep -o "$versionregex" )
		else
			echo "This version of iOS (whatever it is) is unsupported, probably."
			cleanexit
		fi
	fi
	ios=$( echo "$ios" | sed "s|\..*||g" )
	if [ $( echo "$ios" | egrep -c "([0-9]+)" ) -ne 1 ]; then
		echo "Error: Could not determine iOS version!"
		cleanexit
	fi
}

#reset safari's cache, history, current state, etc.
safarireset()
{
	if [[ -z "$safarilocation" || ! -d "$safarilocation" ]]; then
		getsafarilocation
	fi
	killall -9 MobileSafari

	smart_rm "$safarilocation/Caches/Safari" "-rf"
	rm -rf   "$safarilocation"/Safari/History*
	smart_rm "$safarilocation/Safari/SuspendState.plist" "-rf"
	rm -rf   "$safarilocation"/WebKit/WebsiteData/*
	smart_rm "$safarilocation/WebKit/LocalStorage/" "-rf"
	smart_rm "$safarilocation/Webkit/Databases" "-rf"
	rm -rf   "$safarilocation"/Cookies/*
	smart_rm "$safarilocation/Caches/com.apple.mobilesafari/" "-rf"
}

#read the number of crashes from the file, we do this a few times
readcrashes()
{
	crashes=0
	if [[ -e "$config" ]]; then
		if [ $( egrep -c "$crashesfileregex" "$config" ) -ge 1 ]; then
			crashes=$( egrep "$crashesfileregex" "$config" | tail -n 1 | egrep -o "$crashesregex" )
		fi
	fi
}

#read the location of safari cache files from config
readsafari()
{
	if [[ -e "$config" ]]; then
		if [ $( egrep -c "$safarifileregex" "$config" ) -ge 1 ]; then
			safarilocation=$( egrep "$safarifileregex" "$config" | tail -n 1 | egrep -o "$safariregex" )
		fi
	fi
}

#get location of safari's config files
getsafarilocation()
{
	readsafari
	if [[ -z "$safarilocation" || ! -d "$safarilocation" ]]; then
		getversion
		if [ $ios -le 6 ]; then
			safarilocation="/private/var/mobile/Library/"
		elif [ $ios -eq 7 ]; then
			safarilocation=$( find /private/var/mobile/Applications/ -name 'MobileSafari.app' | sed 's|MobileSafari.app|Library/|g' )
		elif [ $ios -ge 8 ]; then
			safarilocation=$( find /private/var/mobile/Containers/Data/Application/ -name 'Safari' | sed 's|Safari||g' )
		fi

		sed -i -r "\@$safarifileregex@d" "$config"
		echo "safari: $safarilocation" >> "$config"

		#check to see if `find` messed up
		if [ $( echo "$safarilocation" | egrep -c "$safariregex" ) -ne 1 ]; then
			echo "Invalid path detected for MobileSafari!(?)"
			cleanexit
		fi

		if [[ -z "$safarilocation" || ! -d "$safarilocation" ]]; then
			echo "Error: Could not retrieve MobileSafari's location!"
			cleanexit
		fi
	fi
}

#main start function, runs when 'start' is the given action
start()
{
	##handle the file param
	#relative paths
	path="$( pwd )"
	if [[ "${file:0:2}" == "./" ]]; then
		file="$path/${file:2}"
	elif [[ "${file:0:3}" == "../" ]]; then
		file="$path/$file"
	fi

	if [[ ! -e "$file" ]]; then
		echo "The provided file does not exist."
		echo "Please check your path and try again."
		cleanexit
	fi

	#determine file extension, warn if none is found
	extension=$( echo $file | sed -r -e 's|.*\.||g' -e 's|(.*)|\L&|' )
	if [[ -z "$extension" ]]; then
		echo "Warning:"
		echo "No file extension found on input file!"
		echo "This can confuse MobileSafari's file handler, it is recommended that you add a file extension to your file."
		while (true);
		do
			echo "Would you like to continue anyway? (y/n)"
			read answer
			if [[ "$answer" =~ [Nn] ]]; then
				cleanexit
			elif [[ "$answer" =~ [Yy] ]]; then
				echo "Continuing..."
				break
			else
				echo "Not a valid reponse; valid responses are 'y', or 'n'."
			fi		
		done
	fi

	smart_cd "$wrkdir/"

	#crash directories
	crashroot="/private/var/mobile/Library/Logs/CrashReporter"
	precrashroot="/private/var/logs/CrashReporter"
	crashpanics="$crashroot/Panics"
	precrashpanics="$precrashroot/Panics"
	crashdirs=( "$crashroot" "$precrashroot" "$crashpanics" "$precrashpanics" )

	#makes sure everything is ready to go
	checks()
	{
		#make files / directories
		for dir in "${crashdirs[@]}"; do
			smart_mkdir "$dir/"
		done
		smart_mkdir "/private/var/log/lighttpd/"
		smart_mkdir "/private/var/www/files/"
		smart_touch "$wrkdir/tested.log"

		#check dependencies
		depends=( "com.innoying.sbutils" "bc" "lighttpd" "adv-cmds" "curl" "wget" "coreutils" "zzuf" )
		checkdepends()
		{
			hasdepends=1
			haszzuf=1
			for package in "${depends[@]}"; do
				if [[ "$package" == "coreutils" ]]; then
					amount=2
				else
					amount=1
				fi
				if [ $( dpkg -l | grep -c "$package" ) -lt $amount ]; then
					echo "Missing '$package'"'!'
					missing=( "${missing[@]}" "$package" )
					hasdepends=0
					if [[ "$package" == "zzuf" ]]; then
						haszzuf=0
					fi
				fi
			done
		}
		checkdepends

		#not all dependencies exist, try to get them
		if [ $hasdepends -eq 0 ]; then
			echo "Not all dependencies were met."
			while (true);
			do
				echo "Would you like me to try installing them? (y/n)"
				read answer
				if [[ "$answer" =~ [Nn] ]]; then
						echo "To install most of the dependencies required, run the following as root:"
						echo "apt-get install ${missing[@]/zzuf/}"
						if [ $haszzuf -eq 0 ]; then
							echo "You can get zzuf at 'https://dl.dropboxusercontent.com/u/33697434/zzuf_0.13-1_iphoneos-arm.deb'."
						fi
						return 1
				elif [[ "$answer" =~ [Yy] ]]; then
					if [[ ! -e /usr/bin/whoami ]]; then
						echo "Because you don't have coreutils, I can't tell if you're running this script as root."
						while (true);
						do
							echo "Are you running this script as root? (y/n)"
							echo "(If you aren't, the installation of missing dependencies will fail.)"
							read answer
							if [[ "$answer" =~ [Nn] ]]; then
									isroot=0
									break
							elif [[ "$answer" =~ [Yy] ]]; then
									isroot=2
									break
							else
									echo "Not a valid reponse; valid responses are 'y', or 'n'."
							fi
						done
					elif [[ "$( whoami )" == "root" ]]; then
						isroot=1
					else
						isroot=0
					fi

					if [ $isroot -ge 1 ]; then
						if [ $( dpkg -l | grep apt7 | grep tool | grep -c Debian ) -eq 1 ]; then
							echo "Installing required dependencies..."
							for package in "${missing[@]}"; do
								if [[ "$package" != "zzuf" ]]; then
									apt-get -y install "$package"
								else
									wget https://dl.dropboxusercontent.com/u/33697434/zzuf_0.13-1_iphoneos-arm.deb --no-check-certificate
									dpkg -i ./zzuf_0.13-1_iphoneos-arm.deb
									if [ $( dpkg -l | grep -c zzuf ) -eq 1 ]; then
										smart_rm ./zzuf_0.13-1_iphoneos-arm.deb
									fi

									#patch zzuf for arm64 if necessary
									if [[ "$( uname -p )" == "arm64" ]]; then
										sed -i 's/\x00\x30\x93\xe4/\x00\x30\x93\xe5/g;s/\x00\x30\xd3\xe4/\x00\x30\xd3\xe5/g;' "$( which zzuf )"
										#test the patch
										zzuf -h &> /dev/null
										if [ $? -ne 0 ]; then
											echo 'zzuf arm64 patch failed!'
											return 1
										else
											echo "Successfully patched zzuf for arm64."
										fi
									fi
								fi

								#set package as 'auto-installed' rather than manually installed
								line=$( grep "$package" -n "$extended_states" | sed "s|:.*||g" )
								if [ $( echo "$line" | egrep -c "([0-9]+)" ) -eq 1 ]; then
									((line++))
									sed -i "$line""s|0|1|g" "$extended_states"
								fi
							done
							checkdepends
							if [ $hasdepends -eq 1 ]; then
								echo "Done! Continuing..."
								break
							else
								echo "Something went wrong with the install, please install the dependencies you're missing manually or try again."
								if [ $isroot -eq 2 ]; then
									echo "Sounds like you weren't actually root, please run this script again as root or complete setup manually."
								fi
							fi
						else
							echo "This script was unable to set up the required dependencies for you because you don't have apt7 installed."
							echo "Install 'APT 0.7 Strict' from Cydia, and try again."
						fi
					else
						echo "This script was unable to set up the required dependencies for you because you're not running this script as root."
						echo "Try running this script again as root, or complete the installation of missing dependencies manually."
					fi
					echo "To install most of the dependencies required, run the following as root:"
					echo "apt-get install ${missing[@]/zzuf/}"
					if [ $haszzuf -eq 0 ]; then
						echo "You can get zzuf at 'https://dl.dropboxusercontent.com/u/33697434/zzuf_0.13-1_iphoneos-arm.deb'."
					fi
					return 1
				else
					echo "Not a valid reponse; valid responses are 'y', or 'n'."
				fi
			done
		fi

		#check for server config
		if [[ ! -e "$lighttpdconf" ]]; then
			echo "No lighttpd.conf file found in /private/etc/!"
			while (true);
			do
				echo "Would you like me to set one up for you? (y/n)"
				read answer
				if [[ "$answer" =~ [Nn] ]]; then
					echo "You'll need to set one up yourself then, see https://ghostbin.com/paste/275n6 for an example."
					return 1
				elif [[ "$answer" =~ [Yy] ]]; then
					echo -n "Setting up..."
					curl -# http://ghostbin.com/paste/275n6/raw > "$lighttpdconf"
					sed -i 's|\r$||' "$lighttpdconf"
					if [[ ! -e "$lighttpdconf" ]]; then
						echo ""
						echo "Something went wrong while setting up the file, please set one up manually or try again."
						echo "See https://ghostbin.com/paste/275n6 for an example."
						return 1
					fi
					echo "Done"
					break
				else
					echo "Not a valid reponse; valid responses are 'y', or 'n'."
				fi
			done
		fi

		#check document-root in server config
		if [ $( egrep -c '(^server.document-root = "/var/www/"[[:space:]]*$|^server.document-root = "/var/www/"[[:space:]]+[#]+.*$)' "$lighttpdconf" ) -ne 1 ]; then
			echo "You must have your document root set up in /private/var/www/"
			echo "Please modify your $lighttpdconf file accordingly."
			return 1
		fi

		#check server port is 80
		if [ $( egrep -c '(^server.port = 80[[:space:]]*$|^server.port = 80[[:space:]]+[#]+.*$)' "$lighttpdconf" ) -ne 1 ]; then
			echo "You must have your server port set to 80."
			echo "Please modify your $lighttpdconf file accordingly."
			return 1
		fi

		#start server
		exitstatus="1"
		curl -# 127.0.0.1 &> /dev/null; exitstatus="$?"
		if [ $exitstatus -ne 0 ]; then
			echo "No server running, attempting to start server..."
			lighttpd -f /etc/lighttpd.conf

			timeout="5"
			counter="0.3"
			exitstatus="1"

			echo -n "Starting server.."
			while (( $( echo ""$timeout" >= "$counter"" | bc ) == 1 && $exitstatus != 0 ));
			do
				sleep 0.3
				echo -n "."
				curl -# 127.0.0.1 &> /dev/null; exitstatus="$?"
				counter=$( bc <<< "scale=1;$counter+ 0.3" )
			done
			if [ $exitstatus -eq 0 ]; then
				echo "Server started."
			else
				echo "Unable to start server."
				return 1
			fi
		fi

		#neuter crash reporting
		if [ $( egrep -c "(^127.0.0.1[[:space:]]+iphonesubmissions.apple.com$)" /private/etc/hosts ) -lt 1 ]; then
			if [[ "$( whoami )" != "root" ]]; then
				echo "Run this script again with root access (this is only required once)."
				return 1
			else
				echo "
#Begin fuzzycactus
127.0.0.1       iphonesubmissions.apple.com
#End fuzzycactus" >> /private/etc/hosts
			fi
		fi

		#check to see if fuzzycactus is already running
		is_running
		if [ $isrunning -eq 1 ]; then
			echo "fuzzycactus is already running!"
			echo "Do 'fuzzycactus watch' to attach to the current process."
			echo "Do 'fuzzycactus stop' to end the current fuzzing session."
			return 1
		fi

		smart_rm "$wrkdir/README"

		return 2
	}

	#run 'checks', exit if the checks fail
	checks
	if [ $? -ne 2 ]; then
		cleanexit
	fi

	##handle option params
	#default values
	slowdown=0
	kernel=0
	time=11
	ratio="0.0001:0.001"

	crashes=0
	didpanic=0

	#config file
	if [[ -e "$config" ]]; then
		#read values from config
		if [ $( egrep -c "$stimefileregex" "$config" ) -ge 1 ]; then
			stime=$( egrep "$stimefileregex" "$config" | tail -n 1 | egrep -o "$stimeregex" )
			didpanic=1
		fi
		if [ $( egrep -c "$ratiofileregex" "$config" ) -ge 1 ]; then
			ratio=$( egrep "$ratiofileregex" "$config" | tail -n 1 | egrep -o "$ratioregex" )
		fi
		if [ $( egrep -c "$timefileregex" "$config" ) -ge 1 ]; then
			time=$( egrep "$timefileregex" "$config" | tail -n 1 | egrep -o "$timeregex" )
		fi
		if [ $( egrep -c "$slowdownfileregex" "$config" ) -ge 1 ]; then
			slowdown=$( egrep "$slowdownfileregex" "$config" | tail -n 1 | egrep -o "$slowdownregex" )
		fi
		if [ $( egrep -c "$kernelfileregex" "$config" ) -ge 1 ]; then
			kernel=$( egrep "$kernelfileregex" "$config" | tail -n 1 | egrep -o "$kernelregex" )
		fi
		readcrashes
	else
		#generate new config file
		echo "###
#
#This is the fuzzycactus config file.
#The values stored here will be used when fuzzycactus starts.
#They will be kept up-to-date with the most recent settings used by fuzzycactus.
#This is so fuzzycactus can resume its work after a kernel panic.
#Modifying this file is not recommended, use fuzzycactus' options instead.
#
###
" > "$config"
	fi

	#parse options
	i=0
	for arg in "${params[@]}"; do
		if [[ "$arg" == "-t" ]]; then
			time="${params[$i+1]}"
		fi
		if [[ "$arg" == "-r" ]]; then
			ratio="${params[$i+1]}"
		fi
		if [[ "$arg" == "-s" ]]; then
			slowdown=1
		fi		
		if [[ "$arg" == "-k" ]]; then
			kernel=1
		fi
		((i++))
	done

	#check the time
	if [ $( echo "$time" | egrep -c "$timeregex" ) -eq 0 ]; then
		echo "The time provided isn't valid."
		echo "Please provide a new time."
		echo -e "$usage"
		cleanexit
	fi

	#check the ratio
	if [ $( echo $ratio | egrep -c "$ratioregex" ) -eq 0 ]; then
		echo "The ratio provided isn't valid."
		echo "Please provide a new ratio."
		echo -e "$usage"
		cleanexit
	fi
	range=( $( echo $ratio | sed "s|:| |g" ) )
	if [[ -n "${range[1]}" ]]; then
		if [ $( echo "${range[0]} > ${range[1]}" | bc ) -eq 1 ]; then
			echo "The ratio provided isn't valid."
			echo "The first ratio argument must be smaller than the second ratio argument."
			echo "Please provide a new ratio."
			echo -e "$usage"
			cleanexit
		elif [ $( echo "${range[0]} == ${range[1]}" | bc ) -eq 1 ]; then
			ratio="${range[0]}"
		fi
	fi

	#write values to config
	if [ $( egrep -c "$ratiofileregex" "$config" ) -ge 1 ]; then
		sed -i "s|$( egrep "$ratiofileregex" "$config" | tail -n 1 )|ratio: $ratio|g" "$config"
	else
		echo "ratio: $ratio" >> "$config"
	fi
	if [ $( egrep -c "$timefileregex" "$config" ) -ge 1 ]; then
		sed -i "s|$( egrep "$timefileregex" "$config" | tail -n 1 )|time: $time|g" "$config"
	else
		echo "time: $time" >> "$config"
	fi
	if [ $( egrep -c "$slowdownfileregex" "$config" ) -ge 1 ]; then
		sed -i "s|$( egrep "$slowdownfileregex" "$config" | tail -n 1 )|slowdown: $slowdown|g" "$config"
	else
		echo "slowdown: $slowdown" >> "$config"
	fi
	if [ $( egrep -c "$kernelfileregex" "$config" ) -ge 1 ]; then
		sed -i "s|$( egrep "$kernelfileregex" "$config" | tail -n 1 )|kernel: $kernel|g" "$config"
	else
		echo "kernel: $kernel" >> "$config"
	fi

	#tell what settings we're using if they aren't the default settings
	smart_touch "./fuzz.log"
	if (( $didpanic == 0 || $kernel == 1 )); then
		if [ $kernel -ne 0 ]; then
			echo "Resume after panic: Enabled" | tee -a "./fuzz.log"
		fi
		if [ $slowdown -ne 0 ]; then
			echo "Slowdown: Enabled" | tee -a "./fuzz.log"
		fi
		if [[ "$time" != "11" ]]; then
			echo "Sleep time: $time" | tee -a "./fuzz.log"
		fi
		if [[ "$ratio" != "0.0001:0.001" ]]; then
			echo "Mutation ratio: $ratio" | tee -a "./fuzz.log"
		else
			echo "Mutation ratio: $ratio" >> "./fuzz.log"
		fi
	fi

	###define some functions we'll need later
	#pull times out of the crash files
	getcrashtime()
	{
		#includes workaround for apparent race condition where crash file exists but has not been populated
		for (( k = 0; k < 3; k++ )); do
			date=( $( grep "Date" "$1" | egrep -o "$dateregex" ) )
			if [[ -z "$date" ]]; then
				sleep 1
				echo "Waiting for crash to finish generating..."
			else
				crashyear="${date[0]:2:2}"
				crashmonth="${date[0]:5:2}"
				crashday="${date[0]:8:2}"
				crashhour="${date[1]:0:2}"
				crashminute="${date[1]:3:2}"
				crashsecond="${date[1]:6:2}"
				break
			fi
		done
		if [ $k -eq 3 ]; then
			echo "Uh, usualliy it doesn't take this long. You may want to take a closer look at this."
		fi
	}

	#sets a point in time before the file is fuzzed
	setstime()
	{
		if [[ -z "$stime" ]]; then
			stime="$( date '+%y.%m.%d-%H.%M.%S' )"
			if [ $( egrep -c "$stimefileregex" "$config" ) -ge 1 ]; then
				sed -i "s|$( egrep "$stimefileregex" "$config" | tail -n 1 )|stime: $stime|g" "$config"
			else
				echo "stime: $stime" >> "$config"
			fi
		fi
		stimearray=( $( echo "$stime" | egrep -o "([0-9]{2})" ) )
		syear="${stimearray[0]}"
		smonth="${stimearray[1]}"
		sday="${stimearray[2]}"
		shour="${stimearray[3]}"
		sminute="${stimearray[4]}"
		ssecond="${stimearray[5]}"
		unset stime
	}

	#determines if a crash has happened since a given time
	comparetimes()
	{
		if [ $crashyear -eq $syear ]; then
			
			if [ $crashmonth -eq $smonth ]; then
				
				if [ $crashday -eq $sday ]; then
					
					if [ $crashhour -eq $shour ]; then

						if [ $crashminute -eq $sminute ]; then
							
							if [ $crashsecond -ge $ssecond ]; then
								foundit
							fi

						elif [ $crashminute -gt $sminute ]; then
							foundit
						fi

					elif [ $crashhour -gt $shour ]; then
						foundit
					fi

				elif [ $crashday -gt $sday ]; then
					foundit
				fi

			elif [ $crashmonth -gt $smonth ]; then
				foundit
			fi

		elif [ $crashyear -gt $syear ]; then
			foundit
		fi
	}

	#do this once you find what crashlog goes with the file
	foundit()
	{
		if [ $( echo "$crash" | grep -c "panic" ) -eq 0 ]; then
			crashtype=$( echo "$crash" | sed -e 's|com.apple.[a-zA-Z]*\.||g' -e 's|_.*||g' -e 's|-.*||g' -e 's|\..*||g' ) #type of crash determined by whatever comes before '-', '_', or '.' in crash name
		else
			crashtype="panic"
		fi

		#create directory if it does not exist, and copy files to that directory
		smart_mkdir "$wrkdir"/Results/"$crashtype"_"$seed"/
		smart_mkdir "$wrkdir/Crashes/"
		cp "$dir"/"$crash" "$wrkdir"/Crashes/
		smart_mv "$dir"/"$crash" "$wrkdir"/Results/"$crashtype"_"$seed"/
		smart_mv /private/var/www/files/"$seed"."$extension" "$wrkdir"/Results/"$crashtype"_"$seed"/

		echo "Moved $crash"
		sed -i -r "s|~$seed .*|&\*|g" "$wrkdir"/tested.log
	}

	#do this if the file crashed something
	crashed()
	{	
		#increment $crashes and write to config
		((crashes++))
		if [ $( egrep -c "$crashesfileregex" "$config" ) -ge 1 ]; then
			sed -i "s|$( egrep "$crashesfileregex" "$config" | tail -n 1 )|crashes: $crashes|g" "$config"
		else
			echo "crashes: $crashes" >> "$config"
		fi

		#find the crashes
		for dir in "${crashdirs[@]}"; do
			smart_cd "$dir/"
			#Remove Duplicates
			if [ $( ls ./ | grep -c "Latest.*plist" ) -ge 1 ]; then
				rm ./Latest*.plist
			fi
			if [ $( ls ./ | grep -c "Latest.*ips" ) -ge 1 ]; then
				rm ./Latest*.ips
			fi
			#Remove crap
			if [ $( ls ./ | grep -c "ResetCounter.*plist" ) -ge 1 ]; then
				rm ./ResetCounter*.plist
			fi
			if [ $( ls ./ | grep -c "ResetCounter.*ips" ) -ge 1 ]; then
				rm ./ResetCounter*.ips
			fi
			if [ $( ls ./ | grep -c "LowBatteryLog.*plist" ) -ge 1 ]; then
				rm ./LowBatteryLog*.plist
			fi
			if [ $( ls ./ | grep -c "LowBatteryLog.*ips" ) -ge 1 ]; then
				rm ./LowBatteryLog*.ips
			fi
			#Fix for iOS7+ crashes
			for crash in *.synced; do
				if [ -e "$crash" ]; then
					if [ $( echo "$crash" | grep -c ".synced" ) -ge 1 ]; then
						smart_mv "$dir/$crash" "$dir/$( echo $crash | sed 's|.synced||g' )"
					fi
				fi
			done
			#Move all crashes to directory with solved file
			for crash in *.plist; do
				if [ -e "$crash" ]; then
					getcrashtime "$crash"
					comparetimes
				fi
			done
			for crash in *.ips; do
				if [ -e "$crash" ]; then
					getcrashtime "$crash"
					comparetimes
				fi
			done

		done
		smart_cd "$wrkdir/"
	}

	injector()
	{
		j=1
		cp "$file" ./file."$extension" &> /dev/null

		#may not be necessary, but the idea is that as your device slows down from testing more files, it will add to the sleep time
		slowdown()
		{
			let j+=1
			if [ $j -ge 15 ]; then
				time=$( bc <<< "scale=1;$time+ 0.1" )
				j=1
				echo "Time incremented"
				#killall mediaserverd
			fi
		}

		#counts the number of both regular crashes, and panics
		crashcount()
		{
			crashcount=$( ls $crashroot/ | grep -c plist )
			let crashcount+=$( ls $crashroot/ | grep -c ips )
			let crashcount+=$( ls $precrashroot/ | grep -c plist )
			let crashcount+=$( ls $precrashroot/ | grep -c ips )
			paniccount=$( ls $crashpanics/ | grep -c plist )
			let paniccount+=$( ls $crashpanics/ | grep -c ips )
			let paniccount+=$( ls $precrashpanics/ | grep -c plist )
			let paniccount+=$( ls $precrashpanics/ | grep -c ips )
		}

		checklocked()
		{
			if [ $exitstatus -ne 0 ]; then
				getversion
				if [ $ios -le 6 ]; then
					echo "Unknown error opening MobileSafari."
				elif [ $ios -ge 7 ]; then
					echo "Error opening MobileSafari, please ensure your device is unlocked."
				fi
				sleep 3
				stop
				cleanexit
			fi
		}

		#generates files and injects them into mobilesafari
		inject()
		{
			echo "~$seed $( date '+%y.%m.%d-%H.%M.%S' )"
			zzuf -c -r $ratio -s $seed < $file > /private/var/www/files/"$seed"."$extension"
			echo "File generated"

			exitstatus="1"
			sbopenurl http://127.0.0.1/files/"$seed"."$extension"; exitstatus="$?"
			checklocked

			echo "Safari opened"
			sleep $time
			safarireset
			echo "Safari has been successfully reset."
			if [ $slowdown -eq 1 ]; then
				slowdown
			fi
			echo "~$seed $( date '+%y.%m.%d-%H.%M.%S' )" >> ./tested.log
		}

		#installs launch daemon so that we can recover from any potential panics
		install_recovery()
		{
			smart_rm "$launchd"
			##keep the plutil commands commented in case I need to dynamically generate the plist later
			##requires erica utils (com.ericasadun.utilities)
			#plutil -create "$launchd" &> /dev/null
			#plutil -AbandonProcessGroup -true "$launchd" &> /dev/null
			#plutil -Label -string com.compilingentropy.fuzzycactus "$launchd" &> /dev/null
			#plutil -ProcessType -string Interactive "$launchd" &> /dev/null
			#plutil -ProgramArguments -array "$launchd" &> /dev/null
			#plutil -key ProgramArguments -arrayadd -value /usr/bin/fuzzycactus "$launchd" &> /dev/null
			#plutil -key ProgramArguments -arrayadd -value start "$launchd" &> /dev/null
			#plutil -key ProgramArguments -arrayadd -value file "$launchd" &> /dev/null
			#plutil -RunAtLoad -true "$launchd" &> /dev/null
#use prebuilt plist to save time + add portability
echo '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
        <key>AbandonProcessGroup</key>
        <true/>
        <key>Label</key>
        <string>com.compilingentropy.fuzzycactus</string>
        <key>ProcessType</key>
        <string>Interactive</string>
        <key>ProgramArguments</key>
        <array>
                <string>/usr/bin/fuzzycactus</string>
                <string>start</string>
                <string>file</string>
        </array>
        <key>RunAtLoad</key>
        <true/>
</dict>
</plist>' > "$launchd"
			sed -i "s|<string>file</string>|<string>$file</string>|g" "$launchd"
		}

		#main injector routine
		install_recovery
		for (( i = $seed; i < 10000; i++ )); do
			seed="$i"
			if [ $( grep -c "~$seed " ./tested.log ) -lt 1 ]; then

				setstime

				crashcount
				before=$crashcount

				inject

				crashcount
				after=$crashcount

				if [ $after -gt $before ]; then
					echo "Crashed!"

					crashed

				else

					smart_rm /private/var/www/files/"$seed"."$extension"

				fi

			else
				echo "Skipping $seed"
			fi
		done

		echo "Fuzzing complete!"
		stop

	}

	#determine what $seed was
	if [ $( egrep -c "([~][0-9]+)" ./tested.log ) -ge 1 ]; then
		seed=$( egrep -o "([~][0-9]+)" ./tested.log | tail -n 1 | egrep -o "([0-9]+)" )
		((seed++))
	else
		seed=1
	fi

	#recover from kpanic
	if [ $didpanic -eq 1 ]; then
		echo "Recovering from unexpected termination..."
		echo "~$seed $( date '+%y.%m.%d-%H.%M.%S' )" >> ./tested.log

		setstime

		crashed

		echo "Recovered successfully."
		if [ $kernel = 0 ]; then
			stop
			cleanexit
		else
			echo "Resuming fuzzing session."
		fi

	fi

	#run the file injector in the background, store its pid to the pidfile
	injector &>> "./fuzz.log" &
	injectorpid=$!

	echo "$injectorpid" >> "$pidfile"

	#watch it go
	if [ $didpanic -eq 0 ]; then
		tail -n 0 -f "./fuzz.log"
	fi
}

#main stop function, runs when 'stop' is the given action
stop()
{
	smart_cd "$wrkdir/"

	readcrashes

	safarireset &> /dev/null

	if [[ -e "$config" ]]; then
		#remove stime from config
		if [ $( egrep -c "$stimefileregex" "$config" ) -ge 1 ]; then
			sed -i -r "\@$stimefileregex@d" "$config"
		fi

		#remove crash count from config
		if [ $( egrep -c "$crashesfileregex" "$config" ) -ge 1 ]; then
			sed -i -r "\@$crashesfileregex@d" "$config"
		fi

		#set kernel=0 in config
		if [ $( egrep -c "$kernelfileregex" "$config" ) -ge 1 ]; then
			sed -i -r "\@$kernelfileregex@d" "$config"
			echo "kernel: 0" >> "$config"
		fi

		#set slowdown=0 in config
		if [ $( egrep -c "$slowdownfileregex" "$config" ) -ge 1 ]; then
			sed -i -r "\@$slowdownfileregex@d" "$config"
			echo "slowdown: 0" >> "$config"
		fi
	fi

	#remove launchdaemon
	if [[ -e "$launchd" ]]; then
		launchctl unload "$launchd" &> /dev/null
		smart_rm "$launchd"
	fi

	#clean up for new fuzzing session
	if [[ -e "./fuzz.log" ]]; then
		echo "Number of crashes: $crashes" | tee -a ./fuzz.log
		if [ $( cat ./fuzz.log | wc -l ) -ge 1 ]; then
			smart_mkdir "./logs/"
			smart_mv "./fuzz.log" "./logs/$( date '+%y.%m.%d-%H.%M.%S' ).log"
		fi
	fi

	#end processes
	removecurrentpid
	if [[ -e "$pidfile" ]]; then
		if [ $( egrep -c "(^[0-9]+$)" "$pidfile" ) -ge 1 ]; then
			while [ $( egrep -c "(^[0-9]+$)" "$pidfile" ) -ge 1 ];
			do
				pid=$( egrep -o "(^[0-9]+$)" "$pidfile" | head -n 1 )
				kill -- -$( ps opgid= "$pid" | tr -d ' ' ) &> /dev/null
				sed -i "/$pid/d" "$pidfile"
			done
			echo "All fuzzycactus processes ended."
		else
			echo "No fuzzycactus process running."
		fi
	else
		echo "no dont do that"
	fi

	smart_rm "$pidfile"
}

#main watch function, runs when 'watch' is the given action
watch()
{
	#detect whether fuzzycactus process is running
	is_running
	if [ $isrunning -eq 1 ]; then
		readcrashes
		echo "Number of crashes so far in this session: $crashes"
		tail -n 1 -f "$wrkdir/fuzz.log"
	else
		echo "No fuzzycactus process running."
	fi
}

#main update function, runs when 'update' is the given action
update()
{
	#if you fork this, update this variable with the link to the raw fuzzycactus on your repo
	repo="https://raw.githubusercontent.com/compilingEntropy/fuzzycactus/master/fuzzycactus"

	curl -sSk "$repo" > "$wrkdir"/fuzzycactus_update
	exitstatus="$?"
	if (( $exitstatus != 0 )); then
		echo "Unable to contact the update server, try again later."
		return 1
	fi
	remoteversion="$( egrep "^version=\"$versionregex\"$" "$wrkdir"/fuzzycactus_update | head -n 1 | egrep -o "$versionregex" 2> /dev/null )"

	if [[ "$( echo -e "$version\n$remoteversion" | sort -r -V | head -n 1 )" != "$version" ]]; then
		echo "Update found!"
		echo "Current version: $version"
		echo "Remote version: $remoteversion"
		while (true);
		do
			echo "Would you like to update? (y/n)"
			read answer
			if [[ "$answer" =~ [Nn] ]]; then
				smart_rm "$wrkdir"/fuzzycactus_update
				return 1
			elif [[ "$answer" =~ [Yy] ]]; then
				echo "Continuing..."
				cat "$wrkdir"/fuzzycactus_update > "$( which fuzzycactus )"
				smart_rm "$wrkdir"/fuzzycactus_update
				newversion="$( egrep "^version=\"$versionregex\"$" "$( which fuzzycactus )" | head -n 1 | egrep -o "$versionregex" )"
				if [[ "$newversion" == "$remoteversion" ]]; then
					echo "Uptated successfully!"
					return 0
				else
					echo "Update failed :/"
					smart_rm "$wrkdir"/fuzzycactus_update
					return 1
				fi
			else
				echo "Not a valid reponse; valid responses are 'y', or 'n'."
			fi
		done
	else
		echo "No updates available."
		smart_rm "$wrkdir"/fuzzycactus_update
		return 0
	fi
}

#main help function, runs when 'help' is the given action
#prints detailed information
helper()
{
	echo "fuzzycactus version: $version"
	echo -e "$usage"
	cat <<EOF

-----
Actions:
start         -Begins a new fuzzing session. This action requires you to provide a file, options
              are optional. Fuzzing will automatically background itself, so it's safe to
              disconnect from your ssh session or ctrl+c after fuzzing starts. As crashes happen,
              they are paired automatically with the files that caused them. These file pairs are
              then placed in '$wrkdir/Results/' for later analysis.
stop          -Stops the current fuzzing session, if one is running, and displays the number of
              crashes that were found during that session. This action takes no files or options.
watch         -Attatches to the current fuzzing session, if one is running. This is essentially the
              equivalent of doing 'tail -f $wrkdir/fuzz.log'. This action takes
              no files or options.
update        -Downloads a new version of fuzzycactus from GitHub if an update is available.
help          -Displays this help message. This action takes no files or options.

Options:
-t (time)     -Changes the time between each reset of MobileSafari. This is useful because it takes
-t 11         longer for a .mov file to load than a .jpg, for example. The default time used is 11,
              which works well for most pictures and documents. It also works well for video files
              which are about 1 second long.
-s (slowdown) -Controls whether or not the time between resets (-t) will grow slowly over time.
              This is useful because things like mediaserverd can get messy after being fuzzed for
              a while, causing MobileSafari to take much longer to load the file. I recommend using
              this option whenever you're fuzzing with anything that gets parsed by mediaserverd,
              such as video or sound files. This option is off by default, and takes no parameters.
-r (ratio)    -Changes the percent of the file that gets modified. If your ratio is 0.004, 0.4% of
-r 0.01:0.1   the file will be randomly modified. You'll want to turn up the ratio if your file is
              parsed correctly most of the time, or turn it down if your file is rarely parsed 
              correctly. This can be a static ratio, such as 0.004, or a range of values, such as
              0.0001:0.001. If you provide a range, the ratio used will be any randomly determined
              value within that range. The default ratio is 0.0001:0.001. I have found this range
              to be effective for many filetypes, using files that are relatively small.
-k (kernel)   -Controls whether or not fuzzing will automatically resume upon reboot in the event
              of a kernel panic. Enabling this option will tell a LaunchDaemon to start fuzzycactus
              again when the device reboots. Regardless of whether this option is set, a
              LaunchDaemon will be temporarily installed to ensure that kernel panics' crash logs
              are paired with the files that caused them when iOS recovers. This option is off by
              default, and takes no parameters.

Examples:
Start fuzzing ./file.mov:
	~$ fuzzycactus start ./file.mov

Start fuzzing ./file.mov, resume fuzzing if there's a panic, account for slowdown:
	~$ fuzzycactus start /var/fuzzycactus/file.mov -k -s

Start fuzzing a large pdf:
	~$ fuzzycactus start ./file.pdf -t 15 -r 0.001:0.01

Stop fuzzing:
	~$ fuzzycactus stop

View the current fuzzing session:
	~$ fuzzycactus watch

Display help:
	~$ fuzzycactus help

-----
General Information:
The working directory for fuzzycactus is $wrkdir/. In this directory you will find
the results of your fuzzing session, as well as a copy of the file you used to fuzz. All crashes
found are placed in $wrkdir/Crashes/ for you to inspect.

fuzzycactus pairs crashes with the files that caused them. The paired files and crashes are found
in $wrkdir/Results/. Previously, fuzzycactus would inform you if there were
crashes that could not be paired with their respective files. This behavior has been depreciated
because pairing is now completely reliable. If your device had a kernel panic while fuzzing,
fuzzycactus will pair the crash the next time iOS boots. No user actions are required for this to
take place.

This tool is designed to be run over ssh. Fuzzing is daemonized, so you can safely ctrl+c and
disconnect your ssh session without fear of interrupting your fuzzing. If you choose to start this
tool via MobileTerminal, stop the script by doing a 'slide-to-power-off' or ssh in and do
'fuzzycactus stop'.

Important Notices:
Do not touch your device while it is fuzzing. This can cause false positives with the
crash-detector or other issues. Before you begin fuzzing, always ensure that your device is
configured not to send diagnostics and usage to Apple. This setting can be changed in
"Settings" > "General" > "About" > "Diagnostics & Usage". Enable the "Don't send" option.

Please report bugs!
email: compilingEntropy@gmail.com
twitter: @compiledEntropy

EOF
}


#looks at the given action and acts appropriately
if [[ "$action" == "start" ]]; then
	if [[ -n "$file" ]]; then
		start
	else
		echo "You must provide a file."
		echo -e "$usage"
	fi
	cleanexit
elif [[ "$action" == "stop" ]]; then
	stop
	exit
elif [[ "$action" == "watch" ]]; then
	watch
	cleanexit
elif [[ "$action" == "update" ]]; then
	update
	cleanexit
elif [[ "$action" == "help" ]]; then
	helper
	cleanexit
else
	echo 'Not a valid action! Allowed actions are: "start", "stop", "watch", and "help".'
	echo -e "$usage"
	cleanexit
fi